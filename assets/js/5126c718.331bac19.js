(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[208],{13:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return i},metadata:function(){return s},toc:function(){return l},default:function(){return p}});var a=n(2122),o=n(9756),r=(n(7294),n(3905)),i={title:"Implementation"},s={unversionedId:"implementation",id:"implementation",isDocsHomePage:!1,title:"Implementation",description:"How, What & Why?",source:"@site/docs/implementation.md",sourceDirName:".",slug:"/implementation",permalink:"/use-fixed/docs/implementation",editUrl:"https://github.com/paulKabira/use-fixed/edit/master/docs/docs/implementation.md",version:"current",frontMatter:{title:"Implementation"},sidebar:"docs",previous:{title:"Usage",permalink:"/use-fixed/docs/usage"},next:{title:"Rules of use-fixed",permalink:"/use-fixed/docs/rules"}},l=[{value:"How, What &amp; Why?",id:"how-what--why",children:[]},{value:"Principles",id:"principles",children:[]}],c={toc:l};function p(e){var t=e.components,n=(0,o.Z)(e,["components"]);return(0,r.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"how-what--why"},"How, What & Why?"),(0,r.kt)("p",null,"Internally, ",(0,r.kt)("strong",{parentName:"p"},"useRef")," and ",(0,r.kt)("strong",{parentName:"p"},"useMemo")," are used to create ",(0,r.kt)("em",{parentName:"p"},"fixed")," references. The overall idea is to internally invalidate the callback reference ",(0,r.kt)("em",{parentName:"p"},"every time")," react commits changes. The library is generalization of ",(0,r.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/hooks-faq.html#how-to-read-an-often-changing-value-from-usecallback"},"often changing callback")," pattern. The implementation is inspired by internal utilities of ",(0,r.kt)("a",{parentName:"p",href:"https://react-table.tanstack.com/"},"react-table"),"."),(0,r.kt)("p",null,"The ",(0,r.kt)("strong",{parentName:"p"},"useCallback")," hook is a optimization technique to add to a Component tree optimized using either ",(0,r.kt)("inlineCode",{parentName:"p"},"React.memo")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"shouldComponentUpdate"),". This can be a hindrance to such component trees. While this will be enough for most use cases, it is rendered pointless when you have a dependency that changes a lot. (eg. an input field, timer etc.)"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"useFixedCallback")," is another way to maintain the same reference. The difference between this and ",(0,r.kt)("inlineCode",{parentName:"p"},"useCallback")," is that ",(0,r.kt)("inlineCode",{parentName:"p"},"useFixedCallback")," does not need a dependency list, yet it always has the latest ",(0,r.kt)("em",{parentName:"p"},"usable state"),". The reference to a ",(0,r.kt)("inlineCode",{parentName:"p"},"FixedCallback")," never changes, and hence, such expensive component trees do not have to update, when the callback updates."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Note: This technique is not recommended by react, but the alternative present at the moment (using ",(0,r.kt)("inlineCode",{parentName:"p"},"dispatch")," and reducers) may not satisfies everyone's use cases. For projects that do not use the ",(0,r.kt)("inlineCode",{parentName:"p"},"redux")," pattern for state management, and rely on hooks/setState need an alternative, which this library intends to provide.")),(0,r.kt)("h2",{id:"principles"},"Principles"),(0,r.kt)("p",null,"The callback returned by ",(0,r.kt)("inlineCode",{parentName:"p"},"useFixedCallback")," has the following interface,"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},'\nconst App = () => {\n  const [counter, setCounter] = useState(0);\n\n  const increment = useFixedCallback((by = 1) => {\n    const value = counter + by;\n    setState(value)\n    return value;\n  });\n\n  const getCounterPowered = useFixedCallback((to = 2) => {\n    return counter ** to;\n  });\n  \n  return <>\n    <h3>Value: {counter}</h3>\n    <button onClick={() => increment(1)}> Increment </button>\n    <PowerByNumber getPowered={getCounterPowered} />\n  </>\n}\n\nexport default App;\n\nconst PowerByNumber = React.memo(({ getPowered }) => {\n  const [poweredBy, setPoweredBy] = useState(3)\n  // consider heavy calculation here. Also, notice the n here.\n  const powered = useMemo(() => getPowered.n(poweredBy), [poweredBy]);\n\n  return <>\n    <h5>Powered To 3 {getPowered.n(2)}</h5>\n    <h4>Type in a number to calculate power to the counter</h4>\n    <input type="number" value={poweredBy} min={3} onChange={() => setPoweredBy(evt.target.value)}>\n    <h4>Powered Counter = {powered}</h4>\n  </>\n});\n')))}p.isMDXComponent=!0}}]);